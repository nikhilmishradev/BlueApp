package com.androidtechguru.blueapp.presentation.ui.viewmodelimport android.util.Logimport androidx.lifecycle.ViewModelimport androidx.lifecycle.viewModelScopeimport com.androidtechguru.blueapp.data.model.Statisticsimport com.androidtechguru.blueapp.domain.model.Imageimport com.androidtechguru.blueapp.domain.model.Itemimport com.androidtechguru.blueapp.domain.usecase.GetImagesUseCaseimport com.androidtechguru.blueapp.domain.usecase.GetItemsUseCaseimport dagger.hilt.android.lifecycle.HiltViewModelimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.flow.MutableSharedFlowimport kotlinx.coroutines.flow.MutableStateFlowimport kotlinx.coroutines.flow.SharedFlowimport kotlinx.coroutines.flow.SharingStartedimport kotlinx.coroutines.flow.StateFlowimport kotlinx.coroutines.flow.asSharedFlowimport kotlinx.coroutines.flow.asStateFlowimport kotlinx.coroutines.flow.catchimport kotlinx.coroutines.flow.flatMapLatestimport kotlinx.coroutines.flow.mapimport kotlinx.coroutines.flow.stateInimport kotlinx.coroutines.launchimport javax.inject.Inject@HiltViewModelclass MainViewModel @Inject constructor(    private val getImagesUseCase: GetImagesUseCase, private val getItemsUseCase: GetItemsUseCase) : ViewModel() {    private val TAG = "MainViewModel"    private val errorTAG = "Error"    private val _images = MutableStateFlow<List<Image>>(emptyList())    val images: StateFlow<List<Image>> = _images    private val _items = MutableStateFlow<List<Item>>(emptyList())    val itemList: StateFlow<List<Item>> = _items    private val _searchQuery = MutableStateFlow("")    private val searchQuery: StateFlow<String> = _searchQuery    private val _currentPage = MutableStateFlow(1)    private val currentPage: StateFlow<Int> = _currentPage    private val _statistics = MutableStateFlow<Statistics>(Statistics())    val statistics: StateFlow<Statistics> = _statistics.asStateFlow()    private val _isBottomSheetVisible = MutableStateFlow(false)    val isBottomSheetVisible: StateFlow<Boolean> = _isBottomSheetVisible    private val _error = MutableSharedFlow<String>()    val error: SharedFlow<String> = _error.asSharedFlow()    init {        loadImages()        loadItemsForCurrentPage(currentPage.value)        viewModelScope.launch {            try {                currentPage                    .collect { page ->                        loadItemsForCurrentPage(page)                    }            } catch (e: Exception) {                handleError(e)            }        }    }    private fun loadImages() {        viewModelScope.launch {            getImagesUseCase()                .catch { e -> handleError(e) }                .collect { imageList ->                    _images.value = imageList                }        }    }    private fun loadItemsForCurrentPage(page: Int = _currentPage.value) {        viewModelScope.launch(Dispatchers.IO) {            getItemsUseCase(page)                .catch { e -> handleError(e) }                .collect { itemList ->                    _items.value = itemList                }        }    }    val filteredItems: StateFlow<List<Item>> = searchQuery.flatMapLatest { query ->        itemList.map { itemList ->            if (query.isBlank()) {                itemList            } else {                itemList.filter {                    it.title.contains(query, true) ||                            it.subtitle.contains(query, ignoreCase = true)                }            }        }    }.stateIn(viewModelScope, SharingStarted.Lazily, emptyList())    fun onFabClicked() {        _isBottomSheetVisible.value = true        calculateStatistics(_items.value)    }    fun closeBottomSheet() {        _isBottomSheetVisible.value = false    }    fun onSearchQueryChanged(query: String) {        _searchQuery.value = query    }    fun onPageChanged(page: Int) {        _currentPage.value = page    }    private fun calculateStatistics(listItems: List<Item>) {        val charFrequency = mutableMapOf<Char, Int>()        val maxOccurrenceCount = 3        listItems.forEach { item ->            (item.title + item.subtitle).forEach { char ->                if (char.isWhitespace().not()) charFrequency[char] =                    charFrequency.getOrDefault(char, 0) + 1            }        }        val topCharacters =            charFrequency.entries.sortedByDescending { it.value }                .take(maxOccurrenceCount)                .map { it.toPair() }        _statistics.value = Statistics(totalItems = listItems.size,            topCharacters = topCharacters)    }    private fun handleError(exception: Throwable) {        Log.v(TAG, "$errorTAG: ${exception.message}")        viewModelScope.launch {            _error.emit("${errorTAG}${exception.message}")        }    }}